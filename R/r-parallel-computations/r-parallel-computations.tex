% Created 2017-03-05 nie 16:38
\documentclass[bigger]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\author{Maxim Litvak}
\date{2016-06-10}
\title{R programming language: parallel computations}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.5.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\tableofcontents

\section{Introduction}
\label{sec-1}
\subsection{Introduction}
\label{sec-1-1}
\subsubsection{A task to produce result Y out of input X may have steps that could be performed in parallel}
\label{sec-1-1-1}
\subsubsection{Example: you need to drink a 1L of beer}
\label{sec-1-1-2}
\begin{enumerate}
\item Ask a friend to help
\label{sec-1-1-2-1}
\item The taks is, thus, parallelized among two throats
\label{sec-1-1-2-2}
\end{enumerate}
\subsection{Who does the job}
\label{sec-1-2}
\subsubsection{you can split the tasks in parallel steps, but who does the job?}
\label{sec-1-2-1}
\subsubsection{Nowadays, each PC usually has 2-8 CPU cores.}
\label{sec-1-2-2}
\begin{enumerate}
\item Each core can process a task!
\label{sec-1-2-2-1}
\end{enumerate}
\subsubsection{You can split the tasks across different computers}
\label{sec-1-2-3}
\begin{enumerate}
\item You can rent them at Microsoft, Amazon etc
\label{sec-1-2-3-1}
\end{enumerate}
\subsection{How it works - MapReduce framework}
\label{sec-1-3}
\subsubsection{Map step - assign to each work a task to perform}
\label{sec-1-3-1}
\subsubsection{Reduce step - collect results from different workers and produce the overall result}
\label{sec-1-3-2}
\section{Loss distribution computation}
\label{sec-2}
\subsection{Basics}
\label{sec-2-1}
\subsubsection{Random numbers used for simulations are "pseudo-random", i.e. a sequence of number that looks random}
\label{sec-2-1-1}
\subsubsection{The starting point is called a "seed". Same seed - same sequence}
\label{sec-2-1-2}
\subsubsection{Any simulation system must be reproducible}
\label{sec-2-1-3}
\subsection{Simulation}
\label{sec-2-2}
\subsubsection{assume we need to calculate 10 million of random numbers}
\label{sec-2-2-1}
\subsubsection{if we can split it among 4 CPU cores than each of them needs to generate only 2.5 millions}
\label{sec-2-2-2}
\subsubsection{we can assign to each core a different seed, generate the numbers and unite the numbers into one}
\label{sec-2-2-3}
\section{Parallel computation in R}
\label{sec-3}
\subsection{Implementation - I}
\label{sec-3-1}
\subsubsection{Loss distribution - non-parallel}
\label{sec-3-1-1}
\begin{verbatim}
loss.dist <- function(seed, N)
{
  set.seed(seed)
  return(runif(N))
}

N <- 4
seed <- 1
print(loss.dist(seed, N))
\end{verbatim}

\begin{verbatim}
[1] 0.2655087 0.3721239 0.5728534 0.9082078
\end{verbatim}

\subsection{Implementation - II}
\label{sec-3-2}
\subsubsection{Explore your ressources}
\label{sec-3-2-1}
\begin{verbatim}
library(parallel)
print(detectCores())
\end{verbatim}

\begin{verbatim}
[1] 4
\end{verbatim}

\subsubsection{Loss distribution - parallel}
\label{sec-3-2-2}
\begin{verbatim}
N <- 4
seed <- 1
print(loss.dist(seed, N))
\end{verbatim}

\subsection{Using library parallel}
\label{sec-3-3}
\subsubsection{A lot of implementation details are hidden in R (e.g. compared to C\#)}
\label{sec-3-3-1}
\subsubsection{General schema}
\label{sec-3-3-2}
\begin{enumerate}
\item Create a cluster (\textbf{makeCluster})
\label{sec-3-3-2-1}
\item Put in the scope of cluster objects (functions, variables etc) which are needed there (\textbf{clusterExport})
\label{sec-3-3-2-2}
\item Send a task (function together with input) to the cluster (\textbf{parLapply}) - similar to apply functions
\label{sec-3-3-2-3}
\end{enumerate}
\subsection{Sum calculation}
\label{sec-3-4}
\subsubsection{Take a trivial task as an example - calculate sum of the sample}
\label{sec-3-4-1}
\subsubsection{divide N numbers sample on M workers}
\label{sec-3-4-2}
\subsubsection{calculate the sums for each workers (in parallel)}
\label{sec-3-4-3}
\subsubsection{collect the results and calculate their sum}
\label{sec-3-4-4}
\subsection{Sum parallel calculation - hands-on}
\label{sec-3-5}
\begin{verbatim}
nc <- 2 # number of cores
cl <- makeCluster(no_cores)
sq <- 1:8
L <- length(sq)
clusterExport(cl, list("sq", "nc", "L"))
# check first that the split is correct
parLapply(cl, 1:nc
  , function(x) sq[(1+(x-1)*L/nc):(x*L/nc)]
	)
# [[1]] 
# [1] 1 2 3 4
# [[2]]
# [1] 5 6 7 8
\end{verbatim}

\subsection{Sum parallel calculation - hands-on II}
\label{sec-3-6}
\begin{verbatim}
res <- parLapply(cl, 1:nc
, function(x) sum(sq[(1+(x-1)*L/nc):(x*L/nc)])
	)
print(res)
# [[1]]
# [1] 10
# [[2]]
# [1] 26
print(sum(unlist(res))) # collect results
# [1] 36
\end{verbatim}

\subsection{Example - wrong implementation}
\label{sec-3-7}
\subsubsection{Farenheit to Celcius}
\label{sec-3-7-1}
\subsection{Task implement Farenheit to Celcius transform in parallel}
\label{sec-3-8}
\subsubsection{Take this as input (correct \textbf{parLapply} call is to be implemented)}
\label{sec-3-8-1}
\begin{verbatim}
library(parallel)
c <- function(t) t*5/9-32
nc <- 4
temps <- seq(10, 40, 10)
cl <- makeCluster(nc)
clusterExport(cl, list("temps"))
\end{verbatim}
\subsection{Example - wrong implementation}
\label{sec-3-9}
\subsubsection{Example attempt}
\label{sec-3-9-1}
\emph{parLapply(cl, 1:nc, function(x) c(temps[x]))}
\subsubsection{However, temperatures are still in Farenheit, what is wrong here?}
\label{sec-3-9-2}
\subsubsection{Try to correct it}
\label{sec-3-9-3}
\subsection{Example - correction}
\label{sec-3-10}
\begin{verbatim}
library(parallel)
C <- function(t) t*5/9-32
nc <- 4
temps <- seq(10, 40, 10)
cl <- makeCluster(nc)
clusterExport(cl, list("temps", "C"))
parLapply(cl, 1:nc, function(x) C(temps[x]))
\end{verbatim}

\begin{verbatim}
[[1]]
[1] -26.44444

[[2]]
[1] -20.88889

[[3]]
[1] -15.33333

[[4]]
[1] -9.777778
\end{verbatim}

\subsection{Example - wrong implementation II}
\label{sec-3-11}
\subsubsection{standard object \textbf{c} was overwritten and wasn't put in the scope of cluster}
\label{sec-3-11-1}
\subsubsection{Even worse it didn't throw an error since the cluster used the default object}
\label{sec-3-11-2}
\subsubsection{Recommended to review the topic on scope in}
\label{sec-3-11-3}
\url{https://github.com/maxlit/workshops/blob/master/R/r-advanced-overview/r-workshop-general-overview.pdf}
\subsection{Pay attention}
\label{sec-3-12}
\subsubsection{Be careful with the scope of the cluster}
\label{sec-3-12-1}
\subsubsection{distribute carefully among work loaders}
\label{sec-3-12-2}
\subsection{Parallel loss distribution calculation}
\label{sec-3-13}
\subsubsection{consider a simple loss generation}
\label{sec-3-13-1}
\begin{verbatim}
loss.dist <- function(seed, N)
{
  set.seed(seed)
  return(runif(N))
}
print(loss.dist(1,4))
# [1] 0.2655087 0.3721239 0.5728534 0.9082078
\end{verbatim}

\begin{verbatim}
[1] 0.2655087 0.3721239 0.5728534 0.9082078
\end{verbatim}

\subsubsection{How to parallelize it?}
\label{sec-3-13-2}
\subsection{Parallel loss calculation}
\label{sec-3-14}
\subsubsection{Possible solution}
\label{sec-3-14-1}
\begin{verbatim}
parallel.loss.dist <- function(seed, N)
{
  no_cores <- 2
  cl <- makeCluster(no_cores)
  clusterExport(cl, list("loss.dist"))
  temp.res <- parLapply(
	cl
	, seed:(seed + 1)
	, function(x) loss.dist(x, N)
	)
  stopCluster(cl)
  return(unlist(temp.res))
}
print(parallel.loss.dist(1,4))
# [1] 0.2655087 0.3721239 0.1848823 0.7023740
\end{verbatim}

\subsection{Questions}
\label{sec-3-15}
\subsubsection{Why the first 2 numbers coincide with non-parallel version and the rest not?}
\label{sec-3-15-1}
\subsubsection{Where is the "Map" step and where is the "Reduce" step hidden in the code?}
\label{sec-3-15-2}
\subsection{Time measurement}
\label{sec-3-16}
\subsubsection{Let's measure time with the following function (not optimal)}
\label{sec-3-16-1}
\begin{verbatim}
measure.time <- function(command)
{
  start.time <- Sys.time()
  eval(parse(text = command))
  end.time <- Sys.time()
  d <- difftime(end.time, start.time
	, units = "secs"))
  return(d)
}
# Example:
# cmd <- "sum(parallel.loss.dist(1, 1e+08))"
# measure.time(cmd)
\end{verbatim}

\subsection{Time measurement II}
\label{sec-3-17}
\subsubsection{play with N to see when it pays off to use parallel or non-parallel version}
\label{sec-3-17-1}
\subsubsection{adjust additionally the number of cores - does it get faster?}
\label{sec-3-17-2}
\subsection{End}
\label{sec-3-18}
\subsubsection{Thank you for your attention}
\label{sec-3-18-1}
\subsubsection{You can find the presentation and the code that was used here at}
\label{sec-3-18-2}
\texttt{github.com/maxlit/workshops/tree/master/R/r-parallel-computations}
% Emacs 24.5.1 (Org mode 8.2.10)
\end{document}
